archestra:
  # The Docker image to use for the Archestra Platform
  # This image contains both the backend API and frontend
  image: archestra/platform:latest

  # Image pull policy for the Archestra container
  # Options: Always, IfNotPresent, Never
  imagePullPolicy: IfNotPresent

  # Number of pod replicas for the Archestra Platform deployment
  replicaCount: 1

  # Deployment strategy configuration for the Deployment
  # See https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/#:~:text=strategy%20(DeploymentStrategy)
  # When null, the default Kubernetes strategy is used
  deploymentStrategy: null

  # Additional environment variables to pass to the container
  # These will be merged with the default DATABASE_URL environment variable
  # Example:
  #   env:
  #     ARCHESTRA_API_BASE_URL: "https://api.example.com"
  #     CUSTOM_VAR: "custom-value"
  env: {}

  # Environment variables from Kubernetes Secrets
  # This allows you to inject sensitive data from secrets into the container
  # See: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data
  # Example:
  #   envFromSecrets:
  #     - name: API_KEY
  #       secretName: my-api-credentials
  #       secretKey: api-key
  #     - name: DATABASE_PASSWORD
  #       secretName: db-credentials
  #       secretKey: password
  envFromSecrets: []

  # Import all key-value pairs from Secrets or ConfigMaps as environment variables
  # This is useful when you want to inject all keys from a Secret/ConfigMap without specifying each one individually
  # See: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#configure-all-key-value-pairs-in-a-secret-as-container-environment-variables
  # Example:
  #   envFrom:
  #     - secretRef:
  #         name: my-secret
  #     - configMapRef:
  #         name: my-configmap
  #     - secretRef:
  #         name: another-secret
  #         optional: true
  envFrom: []

  # Configuration for the MCP Server Runtime
  orchestrator:
    # Base image for MCP server containers
    # If not set, defaults to "europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:latest"
    baseImage: ""

    # Kubernetes configuration for MCP Server Runtime
    # This controls how the Archestra platform connects to Kubernetes to manage MCP server pods
    kubernetes:
      # Namespace where MCP server pods will be created
      # If not set, defaults to the namespace specified in the helm release
      namespace: ""

      # Kubeconfig configuration
      # Choose one of the following methods:

      # Method 1: Use in-cluster configuration (recommended when running inside K8s)
      # No additional configuration needed - the platform will automatically use the service account
      loadKubeconfigFromCurrentCluster: true

      # Method 2: Mount a kubeconfig file from a secret
      # Set useInClusterConfig to false and configure the secret below
      kubeconfig:
        # Enable kubeconfig volume mount
        enabled: false

        # Name of the secret containing the kubeconfig file
        # The secret should have a key named "config" containing the kubeconfig content
        # Example of creating the secret:
        #   kubectl create secret generic archestra-kubeconfig --from-file=config=/path/to/kubeconfig
        secretName: ""

        # Path where the kubeconfig will be mounted inside the container
        # This will be set as the KUBECONFIG environment variable
        mountPath: /etc/kubeconfig

      # ServiceAccount configuration for the Archestra Platform
      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: {}
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""
        # Image pull secrets to attach to the service account (automatically used by pods)
        # This is the recommended way to configure image pull secrets
        # Example:
        #   imagePullSecrets:
        #     - name: myregistrykey
        imagePullSecrets: []

      # RBAC (Role-Based Access Control) configuration
      rbac:
        # Specifies whether RBAC resources should be created
        create: true

  # Service configuration
  service:
    # Service type - ClusterIP, NodePort, or LoadBalancer
    type: ClusterIP
    # Annotations to add to the Kubernetes Service
    annotations: {}
    # Node ports for NodePort service type (optional)
    # Only used when service.type is NodePort
    nodePorts:
      backend: null
      metrics: null
      frontend: null

  # Ingress configuration
  ingress:
    # Enable or disable ingress creation
    enabled: false

    # Annotations for the ingress resource
    annotations: {}

    # Complete ingress specification
    spec: {}

# PostgreSQL configuration
postgresql:
  # External database URL to use instead of deploying a PostgreSQL instance
  # If null, a PostgreSQL instance will be deployed using the Bitnami PostgreSQL chart
  # Example: postgresql://username:password@host:5432/database
  external_database_url: null

  # PostgreSQL subchart configuration (only used when external_database_url is null)
  enabled: true
  auth:
    database: archestra_dev
    username: archestra
    password: archestra_dev_password
  # NOTE: Bitnami is archiving their image.. see these github comments for details
  # (this is essentially why we need to override image.repository and image.tag and global.security.allowInsecureImages)
  #
  # https://github.com/coder/coder/issues/19869#issuecomment-3305875979
  # https://github.com/bitnami/containers/issues/83267
  image:
    repository: bitnamisecure/postgresql
    tag: latest
  global:
    security:
      allowInsecureImages: true
