archestra:
  # The Docker image to use for the Archestra Platform
  # This image contains both the backend API and frontend
  image: archestra/platform:latest

  # Image pull policy for the Archestra container
  # Options: Always, IfNotPresent, Never
  imagePullPolicy: IfNotPresent

  # Number of pod replicas for the Archestra Platform deployment
  # Note: This value is ignored when horizontalPodAutoscaler.enabled is true,
  # as the HPA will manage the replica count dynamically
  replicaCount: 1

  # Deployment strategy configuration for the Deployment
  # See https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/#:~:text=strategy%20(DeploymentStrategy)
  # Default is RollingUpdate with maxUnavailable: 0 to ensure zero-downtime deployments.
  # This ensures at least one pod is always available during updates, which is critical
  # for GKE ingress health checks to always have healthy endpoints.
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1

  # Additional environment variables to pass to the container
  # These will be merged with the default DATABASE_URL environment variable
  # Example:
  #   env:
  #     ARCHESTRA_API_BASE_URL: "https://api.example.com"
  #     CUSTOM_VAR: "custom-value"
  env: {}

  # Environment variables from Kubernetes Secrets
  # This allows you to inject sensitive data from secrets into the container
  # See: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data
  # Example:
  #   envFromSecrets:
  #     - name: API_KEY
  #       secretName: my-api-credentials
  #       secretKey: api-key
  #     - name: DATABASE_PASSWORD
  #       secretName: db-credentials
  #       secretKey: password
  envFromSecrets: []

  # Import all key-value pairs from Secrets or ConfigMaps as environment variables
  # This is useful when you want to inject all keys from a Secret/ConfigMap without specifying each one individually
  # See: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#configure-all-key-value-pairs-in-a-secret-as-container-environment-variables
  # Example:
  #   envFrom:
  #     - secretRef:
  #         name: my-secret
  #     - configMapRef:
  #         name: my-configmap
  #     - secretRef:
  #         name: another-secret
  #         optional: true
  envFrom: []

  # Configuration for the MCP Server Runtime
  orchestrator:
    # Base image for MCP server containers
    # If not set, defaults to "europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:latest"
    baseImage: ""

    # Kubernetes configuration for MCP Server Runtime
    # This controls how the Archestra platform connects to Kubernetes to manage MCP server pods
    kubernetes:
      # Namespace where MCP server pods will be created
      # If not set, defaults to the namespace specified in the helm release
      namespace: ""

      # Kubeconfig configuration
      # Choose one of the following methods:

      # Method 1: Use in-cluster configuration (recommended when running inside K8s)
      # No additional configuration needed - the platform will automatically use the service account
      loadKubeconfigFromCurrentCluster: true

      # Method 2: Mount a kubeconfig file from a secret
      # Set useInClusterConfig to false and configure the secret below
      kubeconfig:
        # Enable kubeconfig volume mount
        enabled: false

        # Name of the secret containing the kubeconfig file
        # The secret should have a key named "config" containing the kubeconfig content
        # Example of creating the secret:
        #   kubectl create secret generic archestra-kubeconfig --from-file=config=/path/to/kubeconfig
        secretName: ""

        # Path where the kubeconfig will be mounted inside the container
        # This will be set as the KUBECONFIG environment variable
        mountPath: /etc/kubeconfig

      # ServiceAccount configuration for the Archestra Platform
      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: {}
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""
        # Image pull secrets to attach to the service account (automatically used by pods)
        # This is the recommended way to configure image pull secrets
        # Example:
        #   imagePullSecrets:
        #     - name: myregistrykey
        imagePullSecrets: []

      # RBAC (Role-Based Access Control) configuration
      rbac:
        # Specifies whether RBAC resources should be created
        create: true

  # Service configuration
  service:
    # Service type - ClusterIP, NodePort, or LoadBalancer
    type: ClusterIP
    # Annotations to add to the Kubernetes Service
    annotations: {}
    # Node ports for NodePort service type (optional)
    # Only used when service.type is NodePort
    nodePorts:
      backend: null
      metrics: null
      frontend: null

  # Ingress configuration
  ingress:
    # Enable or disable ingress creation
    enabled: false

    # Annotations for the ingress resource
    annotations: {}

    # Complete ingress specification
    spec: {}

  # HorizontalPodAutoscaler configuration
  # Automatically scales the number of pod replicas based on observed metrics
  # See: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
  horizontalPodAutoscaler:
    # Enable or disable HorizontalPodAutoscaler creation
    enabled: false

    # Minimum number of replicas the autoscaler can scale down to
    minReplicas: 1

    # Maximum number of replicas the autoscaler can scale up to
    maxReplicas: 10

    # Metrics used to determine scaling behavior
    # Each metric can be of type: Resource, Pods, Object, External, or ContainerResource
    # Example with CPU utilization:
    #   metrics:
    #     - type: Resource
    #       resource:
    #         name: cpu
    #         target:
    #           type: Utilization
    #           averageUtilization: 80
    metrics: []

    # Scaling behavior configuration for scale up and scale down
    # Allows fine-grained control over scaling speed and stabilization
    # Example:
    #   behavior:
    #     scaleDown:
    #       stabilizationWindowSeconds: 300
    #       policies:
    #         - type: Percent
    #           value: 10
    #           periodSeconds: 60
    #     scaleUp:
    #       stabilizationWindowSeconds: 0
    #       policies:
    #         - type: Percent
    #           value: 100
    #           periodSeconds: 15
    behavior: {}

  # PodDisruptionBudget configuration
  # Limits the number of pods that can be down simultaneously during voluntary disruptions
  # See: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    # Enable or disable PodDisruptionBudget creation
    enabled: false

    # Minimum number of pods that must remain available during a disruption
    # Can be an integer (e.g., 1) or a percentage string (e.g., "50%")
    # Only one of minAvailable or maxUnavailable can be set
    minAvailable: null

    # Maximum number of pods that can be unavailable during a disruption
    # Can be an integer (e.g., 1) or a percentage string (e.g., "25%")
    # Only one of minAvailable or maxUnavailable can be set
    maxUnavailable: null

    # Policy for evicting unhealthy pods
    # Options: IfHealthyBudget, AlwaysAllow
    # - IfHealthyBudget: Running pods that are not yet healthy can be evicted only if the guarded application is not disrupted
    # - AlwaysAllow: Running pods that are not yet healthy can be evicted regardless of whether the criteria in a PodDisruptionBudget is met
    # See: https://kubernetes.io/docs/tasks/run-application/configure-pdb/#unhealthy-pod-eviction-policy
    unhealthyPodEvictionPolicy: null

# PostgreSQL configuration
postgresql:
  # External database URL to use instead of deploying a PostgreSQL instance
  # If null, a PostgreSQL instance will be deployed using the Bitnami PostgreSQL chart
  # Example: postgresql://username:password@host:5432/database
  external_database_url: null

  # PostgreSQL subchart configuration (only used when external_database_url is null)
  enabled: true
  auth:
    database: archestra_dev
    username: archestra
    password: archestra_dev_password
  # NOTE: Bitnami is archiving their image.. see these github comments for details
  # (this is essentially why we need to override image.repository and image.tag and global.security.allowInsecureImages)
  #
  # https://github.com/coder/coder/issues/19869#issuecomment-3305875979
  # https://github.com/bitnami/containers/issues/83267
  image:
    repository: bitnamisecure/postgresql
    tag: latest
  global:
    security:
      allowInsecureImages: true
