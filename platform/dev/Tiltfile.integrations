# Integration resources

local_resource(
  'n8n',
  serve_cmd='docker compose -f docker-compose-n8n.yml up n8n --no-deps',
  serve_dir='../',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'mcp-inspector',
  serve_env={
    'DANGEROUSLY_OMIT_AUTH': 'true'
  },
  serve_cmd='npx @modelcontextprotocol/inspector --transport http --server-url http://localhost:9000/v1/mcp',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)

local_resource(
  'orlando-wiremock',
  serve_cmd='docker compose -f ./orlando/docker-compose.yml up wiremock',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'observability',
  serve_cmd='docker compose -f docker-compose.observability.yml up',
  serve_dir='.',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# HashiCorp Vault in K8s (manual trigger)
# Start with: tilt trigger vault
load('ext://helm_remote', 'helm_remote')

helm_remote(
  'vault',
  repo_url='https://helm.releases.hashicorp.com',
  namespace='archestra-dev',
  create_namespace=False,  # Namespace already created by Tiltfile.database
  set=[
    # Run in dev mode (unsealed, in-memory storage)
    'server.dev.enabled=true',
    'server.dev.devRootToken=dev-root-token',
    # Disable injector and CSI (not needed for dev)
    'injector.enabled=false',
    'csi.enabled=false',
    # Resource limits for dev
    'server.resources.requests.memory=256Mi',
    'server.resources.requests.cpu=250m',
  ]
)

k8s_resource(
  'vault',
  port_forwards=['8200:8200'],
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Configure Vault K8s auth with KV v1 (run after vault is started)
# Use this for: ARCHESTRA_HASHICORP_VAULT_KV_VERSION=1, ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=kv/archestra
local_resource(
  'vault-k8s-auth-v1',
  cmd='''
    echo "â³ Waiting for Vault to be ready..."
    for i in {1..30}; do
      if kubectl exec -n archestra-dev vault-0 -- vault status 2>/dev/null | grep -q "Initialized.*true"; then
        echo "âœ… Vault is ready"
        break
      fi
      echo "Waiting... (attempt $i/30)"
      sleep 2
    done

    echo "ðŸ”§ Configuring Vault K8s auth with KV v1..."

    # Enable KV v1 secrets engine at kv/ path
    kubectl exec -n archestra-dev vault-0 -- vault secrets enable -path=kv -version=1 kv 2>/dev/null || true

    # Enable Kubernetes auth method
    kubectl exec -n archestra-dev vault-0 -- vault auth enable kubernetes 2>/dev/null || true

    # Configure K8s auth to use the in-cluster API
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault write auth/kubernetes/config kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"'

    # Create a policy for archestra secrets (KV v1 paths - no /data/ prefix)
    # Note: LIST on kv/archestra requires permission on the path itself, not just kv/archestra/*
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault policy write archestra-secrets-v1 - <<EOF
path "kv/archestra" {
  capabilities = ["list"]
}
path "kv/archestra/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
EOF'

    # Create a role bound to the archestra-platform service account
    kubectl exec -n archestra-dev vault-0 -- vault write auth/kubernetes/role/archestra \
      bound_service_account_names="archestra-platform" \
      bound_service_account_namespaces="archestra-dev" \
      policies="archestra-secrets-v1" \
      ttl="24h"

    echo ""
    echo "âœ… Vault K8s auth configured with KV v1!"
    echo ""
    echo "Configuration:"
    echo "  ARCHESTRA_HASHICORP_VAULT_KV_VERSION=1"
    echo "  ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=kv/archestra"
    echo ""
    echo "Created:"
    echo "  - KV v1 engine at: kv/"
    echo "  - Vault role: archestra (bound to archestra-platform SA)"
    echo "  - Vault policy: archestra-secrets-v1 (path: kv/archestra/*)"
  ''',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Configure Vault K8s auth with KV v2 (run after vault is started)
# Use this for: ARCHESTRA_HASHICORP_VAULT_KV_VERSION=2, ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=secret/data/archestra
local_resource(
  'vault-k8s-auth-v2',
  cmd='''
    echo "â³ Waiting for Vault to be ready..."
    for i in {1..30}; do
      if kubectl exec -n archestra-dev vault-0 -- vault status 2>/dev/null | grep -q "Initialized.*true"; then
        echo "âœ… Vault is ready"
        break
      fi
      echo "Waiting... (attempt $i/30)"
      sleep 2
    done

    echo "ðŸ”§ Configuring Vault K8s auth with KV v2..."

    # Enable KV v2 secrets engine at secret/ path
    kubectl exec -n archestra-dev vault-0 -- vault secrets enable -path=secret kv-v2 2>/dev/null || true

    # Enable Kubernetes auth method
    kubectl exec -n archestra-dev vault-0 -- vault auth enable kubernetes 2>/dev/null || true

    # Configure K8s auth to use the in-cluster API
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault write auth/kubernetes/config kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"'

    # Create a policy for archestra secrets (KV v2 paths - with /data/ and /metadata/ prefixes)
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault policy write archestra-secrets-v2 - <<EOF
path "secret/data/archestra/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
path "secret/metadata/archestra/*" {
  capabilities = ["read", "delete", "list"]
}
EOF'

    # Create a role bound to the archestra-platform service account
    kubectl exec -n archestra-dev vault-0 -- vault write auth/kubernetes/role/archestra \
      bound_service_account_names="archestra-platform" \
      bound_service_account_namespaces="archestra-dev" \
      policies="archestra-secrets-v2" \
      ttl="24h"

    echo ""
    echo "âœ… Vault K8s auth configured with KV v2!"
    echo ""
    echo "Configuration:"
    echo "  ARCHESTRA_HASHICORP_VAULT_KV_VERSION=2"
    echo "  ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=secret/data/archestra"
    echo ""
    echo "Created:"
    echo "  - KV v2 engine at: secret/"
    echo "  - Vault role: archestra (bound to archestra-platform SA)"
    echo "  - Vault policy: archestra-secrets-v2 (paths: secret/data/archestra/*, secret/metadata/archestra/*)"
  ''',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Archestra running in K8s (for testing Vault K8s auth, etc.)
# Start with: tilt trigger archestra-k8s
docker_build(
  'archestra/platform-dev',
  context='..',
  dockerfile='../Dockerfile',
  only=[
    'package.json',
    'pnpm-lock.yaml',
    'pnpm-workspace.yaml',
    'turbo.json',
    'backend',
    'frontend',
    'shared',
    'docker-banner.sh',
  ],
  ignore=[
    '**/node_modules',
    '**/.next',
    '**/dist',
    '**/*.test.ts',
    '**/*.spec.ts',
  ]
)

k8s_yaml(local('''cat <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: archestra-platform
  namespace: archestra-dev
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: archestra-platform-mcp-manager
  namespace: archestra-dev
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "create", "update", "patch", "delete", "watch"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/attach"]
  verbs: ["get", "create"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "create", "update", "patch", "delete", "watch"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch", "delete", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: archestra-platform-mcp-manager
  namespace: archestra-dev
subjects:
- kind: ServiceAccount
  name: archestra-platform
  namespace: archestra-dev
roleRef:
  kind: Role
  name: archestra-platform-mcp-manager
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: Service
metadata:
  name: archestra-platform
  namespace: archestra-dev
spec:
  type: NodePort
  ports:
    - port: 9000
      targetPort: 9000
      nodePort: 30900
      name: backend
    - port: 9050
      targetPort: 9050
      nodePort: 30905
      name: metrics
    - port: 3000
      targetPort: 3000
      nodePort: 30300
      name: frontend
  selector:
    app: archestra-platform
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: archestra-platform
  namespace: archestra-dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: archestra-platform
  template:
    metadata:
      labels:
        app: archestra-platform
    spec:
      serviceAccountName: archestra-platform
      containers:
        - name: archestra
          image: archestra/platform-dev
          imagePullPolicy: Never
          ports:
            - containerPort: 9000
            - containerPort: 9050
            - containerPort: 3000
          env:
            - name: HOSTNAME
              value: "0.0.0.0"
            - name: ARCHESTRA_DATABASE_URL
              value: "postgresql://archestra:archestra_dev_password@postgresql.archestra-dev.svc:5432/archestra_dev?schema=public"
            - name: ARCHESTRA_SECRETS_MANAGER
              value: "Vault"
            - name: ARCHESTRA_HASHICORP_VAULT_ADDR
              value: "http://vault.archestra-dev.svc:8200"
            - name: ARCHESTRA_HASHICORP_VAULT_AUTH_METHOD
              value: "K8S"
            - name: ARCHESTRA_HASHICORP_VAULT_K8S_ROLE
              value: "archestra"
            - name: ARCHESTRA_HASHICORP_VAULT_KV_VERSION
              value: "1"
            - name: ARCHESTRA_HASHICORP_VAULT_SECRET_PATH
              value: "kv/archestra"
            - name: ARCHESTRA_ORCHESTRATOR_LOAD_KUBECONFIG_FROM_CURRENT_CLUSTER
              value: "true"
            - name: ARCHESTRA_ORCHESTRATOR_K8S_NAMESPACE
              value: "archestra-dev"
            - name: ARCHESTRA_ANALYTICS
              value: "disabled"
            - name: ARCHESTRA_ENTERPRISE_LICENSE_ACTIVATED
              value: "true"
EOF
'''))

k8s_resource(
  'archestra-platform',
  port_forwards=['3000:3000', '9000:9000'],
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  resource_deps=['postgresql', 'vault']
)
