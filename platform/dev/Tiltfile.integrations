# Integration resources

local_resource(
  'n8n',
  serve_cmd='docker compose -f docker-compose-n8n.yml up n8n --no-deps',
  serve_dir='../',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'mcp-inspector',
  serve_env={
    'DANGEROUSLY_OMIT_AUTH': 'true'
  },
  serve_cmd='npx @modelcontextprotocol/inspector --transport http --server-url http://localhost:9000/v1/mcp',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)

local_resource(
  'orlando-wiremock',
  serve_cmd='docker compose -f ./orlando/docker-compose.yml up wiremock',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'observability',
  serve_cmd='docker compose -f docker-compose.observability.yml up',
  serve_dir='.',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# HashiCorp Vault in Docker (manual trigger)
# Start with: tilt trigger vault-docker
# Uses dev mode: auto-unsealed, in-memory storage, root token: dev-root-token
# KV v2 engine already enabled at secret/ by default
# .env: ARCHESTRA_SECRETS_MANAGER=Vault, ARCHESTRA_HASHICORP_VAULT_ADDR=http://localhost:8200,
#       ARCHESTRA_HASHICORP_VAULT_TOKEN=dev-root-token
local_resource(
  'vault-docker',
  serve_cmd='docker compose -f docker-compose.vault.yml up',
  serve_dir='.',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# HashiCorp Vault in K8s (manual trigger)
# Start with: tilt trigger vault
load('ext://helm_remote', 'helm_remote')

helm_remote(
  'vault',
  repo_url='https://helm.releases.hashicorp.com',
  namespace='archestra-dev',
  create_namespace=False,  # Namespace already created by Tiltfile.database
  set=[
    # Run in dev mode (unsealed, in-memory storage)
    'server.dev.enabled=true',
    'server.dev.devRootToken=dev-root-token',
    # Disable injector and CSI (not needed for dev)
    'injector.enabled=false',
    'csi.enabled=false',
    # Resource limits for dev
    'server.resources.requests.memory=256Mi',
    'server.resources.requests.cpu=250m',
  ]
)

k8s_resource(
  'vault',
  port_forwards=['8200:8200'],
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Configure Vault K8s auth with KV v1 (run after vault is started)
# Use this for: ARCHESTRA_HASHICORP_VAULT_KV_VERSION=1, ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=kv/archestra
# NOTE: On Windows, run this resource from Git Bash, WSL, or use the PowerShell script in dev/scripts/
local_resource(
  'vault-k8s-auth-v1',
  cmd='''
    echo "â³ Waiting for Vault to be ready..."
    for i in {1..30}; do
      if kubectl exec -n archestra-dev vault-0 -- vault status 2>/dev/null | grep -q "Initialized.*true"; then
        echo "âœ… Vault is ready"
        break
      fi
      echo "Waiting... (attempt $i/30)"
      sleep 2
    done

    echo "ðŸ”§ Configuring Vault K8s auth with KV v1..."

    # Enable KV v1 secrets engine at kv/ path
    kubectl exec -n archestra-dev vault-0 -- vault secrets enable -path=kv -version=1 kv 2>/dev/null || true

    # Enable Kubernetes auth method
    kubectl exec -n archestra-dev vault-0 -- vault auth enable kubernetes 2>/dev/null || true

    # Configure K8s auth to use the in-cluster API
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault write auth/kubernetes/config kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"'

    # Create a policy for archestra secrets (KV v1 paths - no /data/ prefix)
    # Note: LIST on kv/archestra requires permission on the path itself, not just kv/archestra/*
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault policy write archestra-secrets-v1 - <<EOF
path "kv/archestra" {
  capabilities = ["list"]
}
path "kv/archestra/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
EOF'

    # Create a role bound to the archestra-platform service account
    kubectl exec -n archestra-dev vault-0 -- vault write auth/kubernetes/role/archestra \
      bound_service_account_names="archestra-platform" \
      bound_service_account_namespaces="archestra-dev" \
      policies="archestra-secrets-v1" \
      ttl="24h"

    echo ""
    echo "âœ… Vault K8s auth configured with KV v1!"
    echo ""
    echo "Configuration:"
    echo "  ARCHESTRA_HASHICORP_VAULT_KV_VERSION=1"
    echo "  ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=kv/archestra"
    echo ""
    echo "Created:"
    echo "  - KV v1 engine at: kv/"
    echo "  - Vault role: archestra (bound to archestra-platform SA)"
    echo "  - Vault policy: archestra-secrets-v1 (path: kv/archestra/*)"
  ''',
  # Windows: This resource requires bash scripting. Use Git Bash or WSL.
  cmd_bat='echo ERROR: vault-k8s-auth-v1 requires bash. Please run from Git Bash or WSL. && exit /b 1',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Configure Vault K8s auth with KV v2 (run after vault is started)
# Use this for: ARCHESTRA_HASHICORP_VAULT_KV_VERSION=2, ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=secret/data/archestra
# NOTE: On Windows, run this resource from Git Bash, WSL, or use the PowerShell script in dev/scripts/
local_resource(
  'vault-k8s-auth-v2',
  cmd='''
    echo "â³ Waiting for Vault to be ready..."
    for i in {1..30}; do
      if kubectl exec -n archestra-dev vault-0 -- vault status 2>/dev/null | grep -q "Initialized.*true"; then
        echo "âœ… Vault is ready"
        break
      fi
      echo "Waiting... (attempt $i/30)"
      sleep 2
    done

    echo "ðŸ”§ Configuring Vault K8s auth with KV v2..."

    # Enable KV v2 secrets engine at secret/ path
    kubectl exec -n archestra-dev vault-0 -- vault secrets enable -path=secret kv-v2 2>/dev/null || true

    # Enable Kubernetes auth method
    kubectl exec -n archestra-dev vault-0 -- vault auth enable kubernetes 2>/dev/null || true

    # Configure K8s auth to use the in-cluster API
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault write auth/kubernetes/config kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"'

    # Create a policy for archestra secrets (KV v2 paths - with /data/ and /metadata/ prefixes)
    kubectl exec -n archestra-dev vault-0 -- sh -c 'vault policy write archestra-secrets-v2 - <<EOF
path "secret/data/archestra/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
path "secret/metadata/archestra/*" {
  capabilities = ["read", "delete", "list"]
}
EOF'

    # Create a role bound to the archestra-platform service account
    kubectl exec -n archestra-dev vault-0 -- vault write auth/kubernetes/role/archestra \
      bound_service_account_names="archestra-platform" \
      bound_service_account_namespaces="archestra-dev" \
      policies="archestra-secrets-v2" \
      ttl="24h"

    echo ""
    echo "âœ… Vault K8s auth configured with KV v2!"
    echo ""
    echo "Configuration:"
    echo "  ARCHESTRA_HASHICORP_VAULT_KV_VERSION=2"
    echo "  ARCHESTRA_HASHICORP_VAULT_SECRET_PATH=secret/data/archestra"
    echo ""
    echo "Created:"
    echo "  - KV v2 engine at: secret/"
    echo "  - Vault role: archestra (bound to archestra-platform SA)"
    echo "  - Vault policy: archestra-secrets-v2 (paths: secret/data/archestra/*, secret/metadata/archestra/*)"
  ''',
  # Windows: This resource requires bash scripting. Use Git Bash or WSL.
  cmd_bat='echo ERROR: vault-k8s-auth-v2 requires bash. Please run from Git Bash or WSL. && exit /b 1',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

# Archestra running in K8s (for testing Vault K8s auth, etc.)
# Start with: tilt trigger archestra-k8s
docker_build(
  'archestra/platform-dev',
  context='..',
  dockerfile='../Dockerfile',
  only=[
    'package.json',
    'pnpm-lock.yaml',
    'pnpm-workspace.yaml',
    'turbo.json',
    'backend',
    'frontend',
    'shared',
    'docker-banner.sh',
  ],
  ignore=[
    '**/node_modules',
    '**/.next',
    '**/dist',
    '**/*.test.ts',
    '**/*.spec.ts',
  ]
)

k8s_yaml(read_file('./archestra-k8s.yaml'))

k8s_resource(
  'archestra-platform',
  port_forwards=['3000:3000', '9000:9000'],
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  resource_deps=['postgresql', 'vault']
)
