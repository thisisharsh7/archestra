import logger from "@/logging";
import { ToolInvocationPolicyModel } from "@/models";

/**
 * This method will evaluate whether, based on the tool invocation policies assigned to the specified agent,
 * if the tool call is allowed or blocked.
 *
 * If this method returns non-null it is because the tool call was blocked and we are returning a refusal message
 * (in the format of an assistant message with a refusal)
 */
export const evaluatePolicies = async (
  toolCalls: Array<{ toolCallName: string; toolCallArgs: string }>,
  agentId: string,
  contextIsTrusted: boolean,
): Promise<null | [string, string]> => {
  logger.debug(
    { agentId, toolCallCount: toolCalls.length, contextIsTrusted },
    "[toolInvocation] evaluatePolicies: starting evaluation",
  );

  if (toolCalls.length === 0) {
    return null;
  }

  // Parse all tool arguments upfront
  const parsedToolCalls = toolCalls.map((toolCall) => {
    /**
     * According to the OpenAI TS SDK types.. toolCall.function.arguments mentions:
     *
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does
     * not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate
     * the arguments in your code before calling your function.
     *
     * So it is possible that the "JSON" here is malformed because the model hallucinated parameters and we
     * may need to explicitly handle this case in the future...
     */
    return {
      toolCallName: toolCall.toolCallName,
      toolInput: JSON.parse(toolCall.toolCallArgs),
    };
  });

  // Evaluate all tool calls in batch (1-2 queries total instead of N queries)
  const { isAllowed, reason, toolCallName } =
    await ToolInvocationPolicyModel.evaluateBatch(
      agentId,
      parsedToolCalls,
      contextIsTrusted,
    );

  logger.debug(
    { agentId, isAllowed, reason, toolCallName },
    "[toolInvocation] evaluatePolicies: batch evaluation result",
  );

  if (!isAllowed && toolCallName) {
    const toolInput = parsedToolCalls.find(
      (tc) => tc.toolCallName === toolCallName,
    )?.toolInput;

    const archestraMetadata = `
<archestra-tool-name>${toolCallName}</archestra-tool-name>
<archestra-tool-arguments>${JSON.stringify(toolInput)}</archestra-tool-arguments>
<archestra-tool-reason>${reason}</archestra-tool-reason>`;

    const contentMessage = `
I tried to invoke the ${toolCallName} tool with the following arguments: ${JSON.stringify(toolInput)}.

However, I was denied by a tool invocation policy:

${reason}`;

    const refusalMessage = `${archestraMetadata}
${contentMessage}`;

    logger.debug(
      { agentId, toolCallName, reason },
      "[toolInvocation] evaluatePolicies: tool invocation blocked",
    );
    // TODO: return string or null, not provider specific message type
    // return {
    //   finish_reason: "stop",
    //   index: 0,
    //   logprobs: null,
    //   message: {
    //     role: "assistant",
    //     /**
    //      * NOTE: the reason why we store the "refusal message" in both the refusal and content fields
    //      * is that most clients expect to see the content field, and don't conditionally render the refusal field
    //      *
    //      * We also set the refusal field, because this will allow the Archestra UI to not only display the refusal
    //      * message, but also show some special UI to indicate that the tool call was blocked.
    //      */
    //     refusal: refusalMessage,
    //     content: contentMessage,
    //   },
    // };
    return [refusalMessage, contentMessage];
  }

  logger.debug(
    { agentId, toolCallCount: toolCalls.length },
    "[toolInvocation] evaluatePolicies: all tool calls allowed",
  );
  return null;
};
