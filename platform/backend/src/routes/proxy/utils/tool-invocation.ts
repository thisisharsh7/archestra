import logger from "@/logging";
import { ToolInvocationPolicyModel } from "@/models";

/**
 * This method will evaluate whether, based on the tool invocation policies assigned to the specified agent,
 * if the tool call is allowed or blocked.
 *
 * If this method returns non-null it is because the tool call was blocked and we are returning a refusal message
 * (in the format of an assistant message with a refusal)
 */
export const evaluatePolicies = async (
  toolCalls: Array<{ toolCallName: string; toolCallArgs: string }>,
  agentId: string,
  contextIsTrusted: boolean,
): Promise<null | [string, string]> => {
  logger.debug(
    { agentId, toolCallCount: toolCalls.length, contextIsTrusted },
    "[toolInvocation] evaluatePolicies: starting evaluation",
  );

  for (const toolCall of toolCalls) {
    const { toolCallName, toolCallArgs } = toolCall;

    logger.debug(
      { agentId, toolCallName, argsLength: toolCallArgs.length },
      "[toolInvocation] evaluatePolicies: evaluating tool call",
    );

    /**
     * According to the OpenAI TS SDK types.. toolCall.function.arguments mentions:
     *
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does
     * not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate
     * the arguments in your code before calling your function.
     *
     * So it is possible that the "JSON" here is malformed because the model hallucinated parameters and we
     * may need to explicitly handle this case in the future...
     */
    const toolInput = JSON.parse(toolCallArgs);

    logger.debug(
      { agentId, toolCallName, contextIsTrusted },
      "[toolInvocation] evaluatePolicies: calling ToolInvocationPolicyModel.evaluate",
    );

    const { isAllowed, reason } = await ToolInvocationPolicyModel.evaluate(
      agentId,
      toolCallName,
      toolInput,
      contextIsTrusted,
    );

    logger.debug(
      { agentId, toolCallName, isAllowed, reason },
      "[toolInvocation] evaluatePolicies: policy evaluation result",
    );

    const archestraMetadata = `
<archestra-tool-name>${toolCallName}</archestra-tool-name>
<archestra-tool-arguments>${JSON.stringify(toolInput)}</archestra-tool-arguments>
<archestra-tool-reason>${reason}</archestra-tool-reason>`;

    const contentMessage = `
I tried to invoke the ${toolCallName} tool with the following arguments: ${JSON.stringify(toolInput)}.

However, I was denied by a tool invocation policy:

${reason}`;

    const refusalMessage = `${archestraMetadata}
${contentMessage}`;

    if (!isAllowed) {
      logger.debug(
        { agentId, toolCallName, reason },
        "[toolInvocation] evaluatePolicies: tool invocation blocked",
      );
      return [refusalMessage, contentMessage];
      // TODO: return string or null, not provider specific message type
      // return {
      //   finish_reason: "stop",
      //   index: 0,
      //   logprobs: null,
      //   message: {
      //     role: "assistant",
      //     /**
      //      * NOTE: the reason why we store the "refusal message" in both the refusal and content fields
      //      * is that most clients expect to see the content field, and don't conditionally render the refusal field
      //      *
      //      * We also set the refusal field, because this will allow the Archestra UI to not only display the refusal
      //      * message, but also show some special UI to indicate that the tool call was blocked.
      //      */
      //     refusal: refusalMessage,
      //     content: contentMessage,
      //   },
      // };
    }
  }

  logger.debug(
    { agentId, toolCallCount: toolCalls.length },
    "[toolInvocation] evaluatePolicies: all tool calls allowed",
  );
  return null;
};
